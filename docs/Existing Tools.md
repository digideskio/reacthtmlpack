## Existing Tools of Generating index.html with Webpack

Library | Template Using | Cache Busting | Server Rendering | Webpack-Dev-Server with Webpack Server Config |
-------- | -------- | -------- | -------- | -------- |
[reacthtmlpack][reacthtmlpack] | React, Babel | `[chunkhash]` | Two Webpack Configs | Yes |
[react-to-html-webpack-plugin][react-to-html-webpack-plugin] | Function | `[chunkhash]` | One Cfg (`umd`) | No |
[indexhtml-webpack-plugin][indexhtml-webpack-plugin] | HTML | `[contenthash]` | No | No |
[static-site-generator-webpack-plugin][static-site-generator-webpack-plugin] | Function | `[chunkhash]` | One Cfg (`umd`) | No |

[reacthtmlpack]: https://github.com/tomchentw/reacthtmlpack)
[react-to-html-webpack-plugin]: https://github.com/markdalgleish/react-to-html-webpack-plugin)
[indexhtml-webpack-plugin]: https://github.com/unbroken-dome/indexhtml-webpack-plugin)
[static-site-generator-webpack-plugin]: https://github.com/markdalgleish/static-site-generator-webpack-plugin)

The Last thing **Webpack-Dev-Server with Webpack Server Config** is the most important feature.

## Webpack-Dev-Server with Webpack Server Config

### Requirements

* You develop using `webpack-dev-server` with `contentBase` set to `public/` folder
* Your entry point is an `index.html` file generated by some plugin/library
* When you visit http://localhost:8080/, you should see the content of `index.html`
* HMR, react-hot-loader is enabled and supported
* The `index.html` contains **server rendering** components from your app

The last item is the most important feature of `reacthtmlpack`. What does that mean? If you `curl` the page, you should have a server rendered page. It demonstrates that your component is universal and renderable in a node.js context.

All other plugins fails to provide this feature and make them less useful in my case. For example, the static hosted demo page of [react-google-maps][react-google-maps] contains server-rendered markup in `index.html`. That means it support universal JavaScript natively from its design.

In order to do **server rendering**, we have to introduce a concept called **Server Bundling**. 

[react-google-maps]: https://tomchentw.github.io/react-google-maps/

### Server Bundling

The idea is simple:

> Create a separate bundle.js as entry point for the server rendering Component

That means, your node.js application will `require` this `bundle.js` instead of `require("./src/MyComponent")` directly when doing `React.renderToString(<MyComponent />)`. The benefits are:

* The webpack-related stuff are processed before running in node.js context
* You can use [null-loader][null-loader] to disable requiring `.css`, `.eot`, `.woff` files in node.js context
* You could keep using [babel][babel] or client-side related toolchains and don't worry about compatibility
* You don't have to inject lots of `global` variables in your node.js entry point (like `global.__BROWSER = false`)

The front-end toolchain is quickly evolving. Doing **Server Bundling** could help you adapt to the changes. After all, your node.js application and client-side browser shouldn't run on the same set of code. The should run on the **different branch** of the code.

There're some pitfalls that needs your attention:

* You have to include `target: "node"` in your `server-bundling.webpackConfig.js`: http://git.io/vG8W8
* You have to include `libraryTarget: "commonjs2"` to export your Component for node.js: http://git.io/vG81d
* You should treat `dependencies` as `external` resources to prevent duplication and unexpected behaviour: http://git.io/vG8WR

And that's it. After these you should have no problem using **Server Bundling**!

[null-loader]: https://github.com/webpack/null-loader
[babel]: https://babeljs.io/
